# 実装計画: 強化版Slack Bot イベント幹事AIエージェント

**ブランチ**: `002-slack-bot-ai` | **日付**: 2025-09-21 | **仕様書**: [spec_ja.md](./spec_ja.md)
**入力**: 機能仕様書 `/specs/002-slack-bot-ai/spec_ja.md`

## 実行フロー (/planコマンドスコープ)
```
1. 入力パスから機能仕様を読み込み
   → 見つからない場合: エラー "No feature spec at {path}"
2. 技術コンテキストを記入（NEEDS CLARIFICATIONをスキャン）
   → コンテキストからプロジェクトタイプを検出（web=frontend+backend, mobile=app+api）
   → プロジェクトタイプに基づく構造決定を設定
3. 憲章文書の内容に基づいて憲章チェックセクションを記入
4. 以下の憲章チェックセクションを評価
   → 違反が存在する場合: 複雑性追跡に文書化
   → 正当化が不可能な場合: エラー "Simplify approach first"
   → 進捗追跡を更新: 初期憲章チェック
5. フェーズ0を実行 → research.md
   → NEEDS CLARIFICATIONが残る場合: エラー "Resolve unknowns"
6. フェーズ1を実行 → contracts, data-model.md, quickstart.md, エージェント固有テンプレートファイル（例：Claude Code用`CLAUDE.md`、GitHub Copilot用`.github/copilot-instructions.md`、Gemini CLI用`GEMINI.md`）
7. 憲章チェックセクションを再評価
   → 新しい違反がある場合: デザインをリファクタリング、フェーズ1に戻る
   → 進捗追跡を更新: デザイン後憲章チェック
8. フェーズ2を計画 → タスク生成アプローチを記述（tasks.mdは作成しない）
9. 停止 - /tasksコマンド準備完了
```

**重要**: /planコマンドはステップ7で停止します。フェーズ2-4は他のコマンドで実行されます：
- フェーズ2: /tasksコマンドがtasks.mdを作成
- フェーズ3-4: 実装実行（手動またはツール経由）

## 概要
Slack Bot AIエージェントは、DM経由での参加者確認、スケジュール調整、会場予約、Googleカレンダー統合、会議室予約を処理することで、グループイベント（飲み会、ランチ、勉強会）を自律的に企画します。Agent Development Kit (ADK)を使用したマルチエージェントアーキテクチャでGCP Cloud Runにデプロイされます。

## 技術コンテキスト
**言語/バージョン**: Python 3.11+
**主要依存関係**: Agent Development Kit (ADK), Slack Bolt SDK, Google Calendar API, Google Places API, ぐるなびAPI
**ストレージ**: イベント状態管理と参加者データ用GCP Firestore
**テスト**: typingモジュールを使用した型ヒント付きpytest
**対象プラットフォーム**: GCP Cloud Run（コンテナ化デプロイメント）
**プロジェクトタイプ**: single（バックエンドサービス）
**パフォーマンス目標**: 100以上の同時イベント調整セッション処理、500ms未満のAPI応答時間
**制約**: マルチエージェント調整、OAuth2.0統合、リアルタイムSlackインタラクション
**スケール/スコープ**: 1000以上のSlackワークスペースをサポート、月10k以上のイベント管理
**パッケージマネージャ**: Poetry
**コード品質**: リンティングとフォーマット用Ruff
**アーキテクチャ**: 専門タスク用サブエージェントを持つマルチエージェントシステム

## CI/CD
**CI/CDプラットフォーム**: GitHub Actions
**デプロイメント戦略**:
- **auto-deploy**: mainブランチへのマージ時に自動デプロイ（本番環境）
- **manual-deploy**: mainブランチから手動トリガーによるデプロイ（緊急時・ロールバック）
- **ci**: テスト・リント実行（mainブランチおよび全PRに対して）
- **release-drafter**: リリースノート自動生成とバージョン管理

## 憲章チェック
*ゲート: フェーズ0リサーチ前に通過必須。フェーズ1デザイン後に再チェック。*

**ライブラリファースト原則**: ✅ 各コンポーネント（Slackハンドラ、カレンダー統合、会場検索）は独立ライブラリになる
**CLIインターフェース**: ✅ すべてのライブラリはテストとデバッグ用のCLIコマンドを公開
**テストファースト**: ✅ 外部API用契約テスト、ビジネスロジック用単体テストを含むTDDアプローチ
**統合テスト**: ✅ Slack API、Google Calendar API、会場検索API統合に焦点
**型安全性**: ✅ すべての関数シグネチャとデータモデル用Pythonタイピングモジュール
**観測可能性**: ✅ マルチエージェント調整と外部API呼び出し用構造化ログ
**継続的統合**: ✅ GitHub ActionsによるCI/CD、自動テスト・リント・デプロイメント
**シンプリシティ**: ✅ コアイベント調整から開始、高度な機能は延期

## プロジェクト構造

### ドキュメント（この機能）
```
specs/[###-feature]/
├── plan.md              # このファイル（/planコマンド出力）
├── research.md          # フェーズ0出力（/planコマンド）
├── data-model.md        # フェーズ1出力（/planコマンド）
├── quickstart.md        # フェーズ1出力（/planコマンド）
├── contracts/           # フェーズ1出力（/planコマンド）
└── tasks.md             # フェーズ2出力（/tasksコマンド - /planでは作成されない）
```

### ソースコード（リポジトリルート）
```
# オプション1: 単一プロジェクト（デフォルト）
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# オプション2: Webアプリケーション（"frontend" + "backend"が検出された場合）
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# オプション3: モバイル + API（"iOS/Android"が検出された場合）
api/
└── [上記のbackendと同様]

ios/ or android/
└── [プラットフォーム固有構造]
```

**構造決定**: 技術コンテキストがweb/mobileアプリを示さない限りオプション1がデフォルト

## フェーズ0: アウトラインと研究
1. **技術コンテキストから未知の項目を抽出**:
   - 各NEEDS CLARIFICATIONに対して → 研究タスク
   - 各依存関係に対して → ベストプラクティスタスク
   - 各統合に対して → パターンタスク

2. **研究エージェントを生成・派遣**:
   ```
   技術コンテキストの各未知項目について:
     タスク: "{機能コンテキスト}に対する{未知項目}の研究"
   各技術選択について:
     タスク: "{ドメイン}での{技術}のベストプラクティスを見つける"
   ```

3. **research.mdで調査結果を統合**:
   - 決定: [選択されたもの]
   - 理由: [選択理由]
   - 検討された代替案: [評価された他の選択肢]

**出力**: すべてのNEEDS CLARIFICATIONが解決されたresearch.md

## フェーズ1: デザインと契約
*前提条件: research.md完了*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - エンティティ名、フィールド、リレーションシップ
   - 要件からの検証ルール
   - 該当する場合の状態遷移

2. **機能要件からAPI契約を生成**:
   - 各ユーザーアクションに対して → エンドポイント
   - 標準的なREST/GraphQLパターンを使用
   - OpenAPI/GraphQLスキーマを`/contracts/`に出力

3. **契約から契約テストを生成**:
   - エンドポイントごとに1つのテストファイル
   - リクエスト/レスポンススキーマをアサート
   - テストは失敗する必要がある（まだ実装なし）

4. **ユーザーストーリーからテストシナリオを抽出**:
   - 各ストーリー → 統合テストシナリオ
   - クイックスタートテスト = ストーリー検証ステップ

5. **エージェントファイルを段階的に更新**（O(1)操作）:
   - AIアシスタント用に`.specify/scripts/bash/update-agent-context.sh claude`を実行
   - 存在する場合: 現在の計画から新しい技術のみ追加
   - マーカー間の手動追加を保持
   - 最近の変更を更新（最新3つを保持）
   - トークン効率のため150行以下に保持
   - リポジトリルートに出力

**出力**: data-model.md、/contracts/*、失敗するテスト、quickstart.md、エージェント固有ファイル

## フェーズ2: タスク計画アプローチ
*このセクションは/tasksコマンドが実行することを記述 - /plan中は実行しない*

**タスク生成戦略**:
- `.specify/templates/tasks-template.md`をベースとして読み込み
- フェーズ1設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- ADKフレームワークセットアップを伴うマルチエージェント調整タスク
- 契約テストを伴う外部API統合タスク
- ライブラリファースト原則に従うTDD実装タスク

**具体的なタスクカテゴリ**:
1. **インフラストラクチャセットアップ** [P]:
   - ADKエージェントフレームワーク初期化
   - Firestoreデータベーススキーマセットアップ
   - 依存関係を含むPoetryプロジェクト構成
   - Cloud Run用Dockerコンテナ化

2. **契約テストタスク** [P]:
   - Slack Events API契約テスト（slack_events.yaml）
   - Event Coordination API契約テスト（event_coordination.yaml）
   - External APIs契約テスト（external_apis.yaml）
   - 外部APIテスト用モックサーバー

3. **データモデル実装** [P]:
   - 状態マシン検証を持つEventエンティティ
   - 確認ワークフローを持つParticipantエンティティ
   - 予約状況追跡を持つVenueエンティティ
   - カレンダー統合エンティティ
   - Firestoreリポジトリ実装

4. **エージェント実装**（以下の順序で順次実装、各エージェントのインターフェース完了後は並列開発可能）:

   **実装順序**:
   1. **Coordination Agent**（最優先 - 他エージェントの基盤）
      - ADKイベントバスのオーケストレーター
      - エージェント間通信の調停
      - 全体ワークフロー状態管理
      - **完了条件**: 他エージェントとの通信インターフェース定義完了

   2. **Participant Agent**（独立性が高いため第2優先）
      - DMワークフロー管理
      - 参加者確認とデータ収集
      - Slack DM送信・受信処理
      - **依存関係**: Coordination Agentのインターフェース

   3. **Scheduling Agent**（Participantデータに依存）
      - 時間枠最適化アルゴリズム
      - 参加者都合の調整
      - イベントタイプ別スケジュール提案
      - **依存関係**: Participant Agentの確認データ

   4. **Venue Agent**（Schedulingの結果に依存）
      - フォールバック付きマルチAPI検索
      - 会場選択と予約調整
      - 手動フォールバック処理
      - **依存関係**: Scheduling Agentの確定日程

   5. **Calendar Agent**（最終統合 - 全エージェントの結果が必要）
      - OAuth2.0 + Google Workspace統合
      - カレンダーイベント作成
      - 会議室予約処理
      - **依存関係**: Scheduling Agent（日程）+ Venue Agent（場所）

5. **統合タスク**:
   - Slack Bolt SDKイベント処理
   - OAuth委任を持つGoogle Calendar API
   - レート制限付きGoogle Places API
   - エラーハンドリング付きぐるなびAPI
   - ADKイベントシステム経由のマルチエージェント調整

6. **ユーザーストーリー実装**:
   - 食事イベントエンドツーエンドワークフロー
   - 会議室予約付き勉強会/会議イベント
   - 中間確認ワークフロー
   - エラーハンドリングと手動フォールバックシナリオ

7. **CLIツール** [P]:
   - テスト用イベント調整CLI
   - 参加者シミュレーションCLI
   - 会場検索テストCLI
   - カレンダー統合テストCLI

8. **CI/CDパイプライン** [P]:
   - GitHub Actions CI ワークフロー（テスト・リント実行）
   - Auto-deploy ワークフロー（mainブランチ自動デプロイ）
   - Manual-deploy ワークフロー（手動トリガーデプロイ）
   - Release-drafter ワークフロー（リリースノート自動生成）
   - GCP Cloud Run デプロイメント設定
   - 環境変数管理（GitHub Secrets → GCP Secret Manager）

**順序戦略**:
- TDD順序: 契約テスト → モデル → エージェント → 統合テスト
- 依存関係順序: インフラストラクチャ → データ層 → ビジネスロジック → 外部統合
- 並列実行のため[P]マーク（独立ファイル/エージェント）
- エージェント間調整ロジックのための順次タスク

**推定出力**: tasks.mdに40-45の番号付き、順序付きタスク
- インフラストラクチャ: 5タスク
- 契約テスト: 8タスク [P]
- データモデル: 6タスク [P]
- エージェント実装: 12タスク（順次実行、明確な依存関係あり）
- 外部統合: 6タスク
- CLIツール: 4タスク [P]
- CI/CDパイプライン: 6タスク [P]
- ドキュメント/デプロイメント: 3タスク

**タスク依存関係**:
- すべての契約テストは並列実行可能
- データモデルはFirestoreセットアップに依存
- エージェント実装は以下の順序で依存:
  ```
  Coordination Agent（基盤）
  ↓
  Participant Agent（独立性高）
  ↓
  Scheduling Agent（参加者データ依存）
  ↓
  Venue Agent（確定日程依存）
  ↓
  Calendar Agent（日程+場所依存）
  ```
- 外部統合は対応エージェントの実装に依存
- 統合テストはすべてのコンポーネントに依存

**重要**: このフェーズは/tasksコマンドで実行され、/planでは実行されません

## フェーズ3以降: 将来の実装
*これらのフェーズは/planコマンドのスコープを超えています*

**フェーズ3**: タスク実行（/tasksコマンドがtasks.mdを作成）
**フェーズ4**: 実装（憲章原則に従ってtasks.mdを実行）
**フェーズ5**: 検証（テスト実行、quickstart.md実行、パフォーマンス検証）

## 複雑性追跡
*憲章チェックで正当化が必要な違反がある場合のみ記入*

| 違反 | 必要な理由 | よりシンプルな代替案が却下された理由 |
|-----------|------------|-------------------------------------|
| [例：4番目のプロジェクト] | [現在の必要性] | [3プロジェクトでは不十分な理由] |
| [例：リポジトリパターン] | [具体的な問題] | [直接DB アクセスでは不十分な理由] |


## 進捗追跡
*このチェックリストは実行フロー中に更新されます*

**フェーズ状況**:
- [x] フェーズ0: 研究完了（/planコマンド）
- [x] フェーズ1: デザイン完了（/planコマンド）
- [x] フェーズ2: タスク計画完了（/planコマンド - アプローチのみ記述）
- [ ] フェーズ3: タスク生成（/tasksコマンド）
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲート状況**:
- [x] 初期憲章チェック: 合格
- [x] デザイン後憲章チェック: 合格
- [x] すべてのNEEDS CLARIFICATION解決済み
- [ ] 複雑性逸脱が文書化済み

---
*憲章v2.1.1に基づく - `/memory/constitution.md`を参照*